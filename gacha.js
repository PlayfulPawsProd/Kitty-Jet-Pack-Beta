// ~~~ gacha.js ~~~ //
// Kana's Kapsule Khaos Machine - Where did the Sparkles Go?! Nya~!

// --- Gacha Settings ---
const GACHA_COST = 0; // Still free! Spoiled Master! >.<
const PULL_ANIMATION_DURATION = 300;

// --- Gacha Prize Pool --- (NEW!) ---
let gachaColorPool = []; // This will hold item IDs, weighted by rarity!
let prizeDisplay = null; // { item: object, isNew: boolean } -> Stores the revealed prize details
let pendingPrizeId = null; // Store the ID before reveal

// --- Gacha Screen UI Elements ---
let gachaBackButton; let gachaPullButton; let machineBox;

// --- Gacha Animation State ---
let isGachaAnimating = false; let gachaAnimationTimer = 0; let currentGachaStep = 'idle';
let spentPlushieParticles = []; let sparkParticles = []; let smokeParticles = [];

// --- Mika Commentary (Gacha Specific) ---
let gachaMikaCommentary = ""; // Renamed variable
let gachaMikaCommentaryTimer = 0;
const GACHA_MIKA_COMMENTARY_DURATION = 240; // Renamed constant

// --- Particle Settings ---
const MAX_SMOKE_PARTICLES = 15; const MAX_SPARK_PARTICLES = 20; const MAX_PLUSHIE_PARTICLES = 10;

// --- Function to Create Weighted Gacha Pool ---
function createGachaPool() { console.log("Creating Gacha Pool..."); gachaColorPool = []; if (typeof storeItems === 'undefined' || !Array.isArray(storeItems)) { console.error("Cannot create gacha pool: storeItems missing!"); gachaColorPool.push('error_pool_creation_failed'); return; } const rarityWeights = { common: 15, uncommon: 7, rare: 3, super_rare: 1 }; storeItems.forEach(item => { if (item && item.type === 'kitty_color' && item.id !== 'default') { let weight = rarityWeights[item.rarity] || 1; for (let i = 0; i < weight; i++) { gachaColorPool.push(item.id); } } }); if (gachaColorPool.length === 0) { console.error("Gacha Pool empty!"); gachaColorPool.push('error_empty_pool'); } else { console.log(`Gacha Pool created: ${gachaColorPool.length} entries.`); } }

// --- Calculate dynamic Gacha layout elements ---
function setupGachaLayout(canvasW, canvasH) { console.log(`>>> Calculating Gacha layout with W=${canvasW}, H=${canvasH}`); let safeW = Number(canvasW) || 600; let safeH = Number(canvasH) || 400; if (isNaN(safeW) || isNaN(safeH) || safeW <= 0 || safeH <= 0) { console.error("!!! Invalid canvas dimensions passed to setupGachaLayout:", canvasW, canvasH, "Using defaults:", safeW, safeH); safeW = 600; safeH = 400; } try { gachaBackButton = { x: 15, y: safeH - 65, w: 100, h: 40 }; let machineWidth = safeW * 0.6; let machineHeight = safeH * 0.6; console.log(`>>> Calculated machine dims: W=${machineWidth.toFixed(1)}, H=${machineHeight.toFixed(1)}`); if (isNaN(machineWidth) || isNaN(machineHeight) || machineWidth <= 0 || machineHeight <= 0) { console.error(">>> !!! Calculated machineWidth or machineHeight is invalid!", machineWidth, machineHeight); machineBox = {x: safeW * 0.2, y: safeH * 0.2, w: safeW * 0.6, h: safeH * 0.6, fallback: true, error: "BadDims"}; } else { let boxX = safeW / 2 - machineWidth / 2; let boxY = safeH * 0.18; console.log(`>>> Calculated machine pos: X=${boxX.toFixed(1)}, Y=${boxY.toFixed(1)}`); if (isNaN(boxX) || isNaN(boxY)) { console.error(">>> !!! Calculated machineBox X or Y is NaN!", boxX, boxY); machineBox = {x: safeW * 0.2, y: safeH * 0.2, w: machineWidth, h: machineHeight, fallback: true, error: "BadPos"}; } else { machineBox = { x: boxX, y: boxY, w: machineWidth, h: machineHeight }; } } if (machineBox && typeof machineBox.w === 'number' && machineBox.w > 0 && !machineBox.error) { let pullButtonSize = machineBox.w * 0.3; let pullX = machineBox.x + machineBox.w / 2 - pullButtonSize / 2; let pullY = machineBox.y + machineBox.h * 0.65; let pullW = pullButtonSize; let pullH = pullButtonSize * 0.7; if (isNaN(pullX) || isNaN(pullY) || isNaN(pullW) || isNaN(pullH) || pullW <= 0 || pullH <= 0) { console.error(">>> Invalid values calculated for gachaPullButton! Using fallback.", {pullX, pullY, pullW, pullH}); gachaPullButton = {x: machineBox.x + 20, y: machineBox.y + machineBox.h - 60, w: 80, h: 40, fallback: true, error:"BadPullCalc"}; } else { gachaPullButton = { x: pullX, y: pullY, w: pullW, h: pullH }; } } else { console.warn(">>> MachineBox error/invalid dims, using fallback pull button."); gachaPullButton = {x: (machineBox ? machineBox.x + 20 : 70), y: (machineBox ? machineBox.y + machineBox.h - 60 : 150), w: 80, h: 40, fallback: true, error:"MachineBoxError"}; } console.log(">>> Gacha layout calculation finished. machineBox:", machineBox, "gachaPullButton:", gachaPullButton); } catch (e) { console.error("Error in setupGachaLayout:", e); gachaBackButton = {x:0,y:0,w:1,h:1}; machineBox={x:50,y:50,w:100,h:200, fallback:true, error:"Catch"}; gachaPullButton={x:75, y:150, w:50, h:40, fallback:true, error:"Catch"};} }

// --- Display Gacha Screen ---
function displayGacha(currentTotalPlushies) {
    const dependencies = [ { name: 'width', value: width }, { name: 'height', value: height }, { name: 'machineBox', value: machineBox }, { name: 'gachaPullButton', value: gachaPullButton }, { name: 'gachaBackButton', value: gachaBackButton }, { name: 'color', value: color }, { name: 'storeItems', value: storeItems }, { name: 'drawStaticKitty', value: drawStaticKitty }, { name: 'getColorValueById', value: getColorValueById }, { name: 'isItemCollected', value: isItemCollected }, { name: 'textColor', value: textColor }, { name: 'textStrokeColor', value: textStrokeColor }, { name: 'backButtonColor', value: backButtonColor }, { name: 'kittyColor', value: kittyColor} ]; let missingDep = null; for (const dep of dependencies) { if (typeof dep.value === 'undefined' || dep.value === null) { missingDep = dep.name; break; } } if (missingDep) { console.error(`Gacha display dependency missing: ${missingDep}!`); background(0); fill(255, 0, 0); textSize(20); textAlign(CENTER, CENTER); text(`Gacha Error!\nMissing: ${missingDep}\nCheck console.`, width / 2, height / 2); return; }
    if (gachaColorPool.length === 0) { createGachaPool(); } if (gachaColorPool.length > 0 && gachaColorPool[0].startsWith('error_')) { background(0); fill(255,0,0); textSize(18); textAlign(CENTER,CENTER); text(`Gacha Pool Error!\n(${gachaColorPool[0]})`, width/2, height/2); drawGachaBackButton(); return; }
    try { if (isGachaAnimating) { updateGachaAnimation(); } else { if (frameCount % 45 === 0 && smokeParticles.length < MAX_SMOKE_PARTICLES / 2) { spawnSmokeParticle(machineBox.x + machineBox.w * 0.85, machineBox.y + machineBox.h * 0.1); } } updateSmokeParticles(); updateSparkParticles(); updateSpentPlushieParticles(); fill(30, 30, 40, 230); rectMode(CORNER); rect(0, 0, width, height); fill(textColor); stroke(textStrokeColor); strokeWeight(3); textSize(min(width, height) * 0.07); textAlign(CENTER, TOP); text("Kana's Kapsule Khaos!", width / 2, height * 0.04); textSize(min(width, height) * 0.04); strokeWeight(2); text(`Your Plushies: ${currentTotalPlushies}`, width / 2, height * 0.11); noStroke(); push(); if (currentGachaStep === 'shaking' || currentGachaStep === 'sparking' || currentGachaStep === 'poofing') { translate(random(-3, 3), random(-1.5, 1.5)); } drawMachineBase(); pop(); drawSmokeParticles(); drawSparkParticles(); drawSpentPlushieParticles(); drawPrizeDisplay(); drawPullButton(currentTotalPlushies); drawGachaBackButton(); drawGachaMika(); textAlign(CENTER, CENTER); noStroke(); } catch(e) { console.error("Error during displayGacha draw:", e); background(0); fill(255,0,0); textSize(18); textAlign(CENTER,CENTER); text(`Gacha Draw Error! ${e.message}`, width/2, height/2); }
}

// --- Helper to Set Gacha Mika's Commentary ---
function setGachaMikaCommentary(text) { gachaMikaCommentary = text; gachaMikaCommentaryTimer = GACHA_MIKA_COMMENTARY_DURATION; }

// --- Sub-Drawing Functions ---
function drawMachineBase() { if (!machineBox || typeof machineBox.x !== 'number' || typeof machineBox.y !== 'number' || typeof machineBox.w !== 'number' || typeof machineBox.h !== 'number' || machineBox.w <= 0 || machineBox.h <= 0 ) { console.error(">>> drawMachineBase called with invalid machineBox:", machineBox); fill(255, 0, 0, 150); rectMode(CORNER); rect(10, 10, width - 20, height - 20); fill(255); textSize(20); textAlign(CENTER,CENTER); text("Machine Box Error!", width/2, height/2); return; } rectMode(CORNER); if (machineBox.fallback) { fill(255, 0, 255); console.log(">>> Using Fallback Machine Color!") } else { fill(100, 100, 110); } rect(machineBox.x, machineBox.y, machineBox.w, machineBox.h, 10); fill(80); rect(machineBox.x + machineBox.w * 0.8, machineBox.y, machineBox.w * 0.1, machineBox.h * 0.15); fill(90); triangle( machineBox.x + machineBox.w * 0.1, machineBox.y, machineBox.x + machineBox.w * 0.3, machineBox.y, machineBox.x + machineBox.w * 0.2, machineBox.y + machineBox.h * 0.15 ); fill(40); rect(machineBox.x + machineBox.w * 0.3, machineBox.y + machineBox.h * 0.85, machineBox.w * 0.4, machineBox.h * 0.1); fill(255, 220, 0); rect(machineBox.x + machineBox.w * 0.05, machineBox.y + machineBox.h * 0.75, machineBox.w * 0.2, machineBox.h * 0.1); fill(0); textSize(min(width, height) * 0.018); textAlign(CENTER, CENTER); text("!!DANGER!!", machineBox.x + machineBox.w * 0.15, machineBox.y + machineBox.h * 0.8); }
function drawPullButton(currentTotalPlushies) { if (!gachaPullButton || typeof gachaPullButton.x !== 'number' || typeof color !== 'function') { console.error("Cannot draw Pull Button - data/color missing"); return; } let btnColor = color(200, 0, 0); let btnTextColor = color(255); let btnText = `Pull! (${GACHA_COST === 0 ? 'Free!' : GACHA_COST})`; if (isGachaAnimating) { btnColor = color(100); btnTextColor = color(150); btnText = "Working..."; } else if (GACHA_COST > 0 && currentTotalPlushies < GACHA_COST) { btnColor = color(150, 0, 0); btnTextColor = color(200); } rectMode(CORNER); fill(btnColor); stroke(50); strokeWeight(1); rect(gachaPullButton.x, gachaPullButton.y, gachaPullButton.w, gachaPullButton.h, 5); fill(btnTextColor); noStroke(); textSize(min(width, height) * 0.03); textAlign(CENTER, CENTER); text(btnText, gachaPullButton.x + gachaPullButton.w / 2, gachaPullButton.y + gachaPullButton.h / 2); }
function drawGachaBackButton() { if (!gachaBackButton || !backButtonColor || !textColor || !textStrokeColor) { console.error("Cannot draw Back Button - data/colors missing"); return; } try { fill(backButtonColor); rectMode(CORNER); noStroke(); rect(gachaBackButton.x, gachaBackButton.y, gachaBackButton.w, gachaBackButton.h, 5); fill(textColor); textSize(min(width, height) * 0.04); textAlign(CENTER, CENTER); stroke(textStrokeColor); strokeWeight(1.5); text("Back", gachaBackButton.x + gachaBackButton.w / 2, gachaBackButton.y + gachaBackButton.h / 2); noStroke(); } catch (e) { console.error("Error drawing gacha back button:", e); } }
function drawGachaMika() { if (!width || !height || typeof drawStaticKitty !== 'function' || typeof kittyColor === 'undefined' || !heartColor || !gachaBackButton || typeof gachaBackButton.x === 'undefined') { console.error("Deps missing for drawGachaMika!"); return; } try { let mikaSize = min(width, height) * 0.12; let bottomBuffer = 40; let mikaX = width / 2; let mikaY = height - (mikaSize / 2) - bottomBuffer; if (mikaX - mikaSize / 2 < gachaBackButton.x + gachaBackButton.w + 10) { mikaX = gachaBackButton.x + gachaBackButton.w + 10 + mikaSize / 2; } drawStaticKitty(mikaX, mikaY, mikaSize); if (gachaMikaCommentaryTimer <= 0 && gachaMikaCommentary === "") { setGachaMikaCommentary("Push the button, Master! Let's see what happens!"); } if (gachaMikaCommentaryTimer > 0) { gachaMikaCommentaryTimer--; let bubbleW = width * 0.6; let bubbleH = height * 0.1; let bubbleX = mikaX - bubbleW / 2; let bubbleY = mikaY - bubbleH - mikaSize * 0.8; bubbleX = constrain(bubbleX, 5, width - bubbleW - 5); bubbleY = constrain(bubbleY, 5, height - bubbleH - 5); fill(240, 240, 240, 220); stroke(50); strokeWeight(1); rect(bubbleX, bubbleY, bubbleW, bubbleH, 10); triangle(bubbleX + bubbleW / 2 - 10, bubbleY + bubbleH, bubbleX + bubbleW / 2 + 10, bubbleY + bubbleH, mikaX, mikaY - mikaSize * 0.35); fill(50); noStroke(); textSize(min(width, height) * 0.03); textAlign(LEFT, TOP); text(gachaMikaCommentary, bubbleX + 15, bubbleY + 10, bubbleW - 30); textAlign(CENTER, CENTER); } else { gachaMikaCommentary = ""; } } catch (e) { console.error("Error drawing gacha Mika:", e); } }

// --- Animation Logic (ADDED PARTICLE SPAWN LOGS) ---
function startGachaAnimation() { if (gachaColorPool.length === 0 || gachaColorPool[0].startsWith('error_')) { console.error("Cannot start gacha: Pool invalid!"); setGachaMikaCommentary("Nya? The machine seems broken..."); return; } console.log(">>> Setting isGachaAnimating to TRUE"); isGachaAnimating = true; gachaAnimationTimer = 0; currentGachaStep = 'shaking'; prizeDisplay = null; spentPlushieParticles = []; sparkParticles = []; let rawPrizeId = random(gachaColorPool); if (typeof storeItems === 'undefined') { console.error("storeItems missing!"); pendingPrizeId = null; } else { let prizeItem = storeItems.find(item => item && item.id === rawPrizeId); if (!prizeItem) { console.error(`Pulled invalid ID: ${rawPrizeId}!`); pendingPrizeId = null; } else { pendingPrizeId = prizeItem.id; console.log(`Gacha prize determined: ${pendingPrizeId} (${prizeItem.name})`); } } setGachaMikaCommentary("Here we go! Don't break, stupid machine!"); console.log("Gacha animation started: shaking"); }
function updateGachaAnimation() { gachaAnimationTimer++; if (currentGachaStep === 'shaking' && gachaAnimationTimer > 60) { currentGachaStep = 'sparking'; setGachaMikaCommentary("Eek! Zappy! Is that safe?!"); console.log(">>> State: Sparking"); } else if (currentGachaStep === 'sparking' && gachaAnimationTimer > 150) { currentGachaStep = 'poofing'; setGachaMikaCommentary("POOF! There go my plushies... Hope it's worth it!"); console.log(">>> State: Poofing, calling spawnSpentPlushieParticles..."); spawnSpentPlushieParticles(); console.log(">>> Called spawnSpentPlushieParticles.");} else if (currentGachaStep === 'poofing' && gachaAnimationTimer > 240) { currentGachaStep = 'dropping'; setGachaMikaCommentary("Clunk! What was that...?"); console.log(">>> State: Dropping"); } else if (currentGachaStep === 'dropping' && gachaAnimationTimer > PULL_ANIMATION_DURATION - 30) { currentGachaStep = 'revealing'; console.log(">>> State: Revealing"); if (typeof isItemCollected !== 'function' || typeof storeItems === 'undefined') { console.error("Deps missing for reveal!"); setGachaMikaCommentary("Nya! Error checking prize!"); prizeDisplay = { item: { name: "System Error!", type:'error' }, isNew: false }; } else if (!pendingPrizeId) { console.error("No prize ID!"); setGachaMikaCommentary("Huh? Nothing?! Rigged!"); prizeDisplay = { item: { name: "Nothing!", type:'error' }, isNew: false }; } else { let prizeItem = storeItems.find(item => item && item.id === pendingPrizeId); if (!prizeItem) { console.error("Prize ID invalid!"); setGachaMikaCommentary("Wha-? Prize vanished!"); prizeDisplay = { item: { name: "Error!", type:'error' }, isNew: false }; } else { let isNew = !isItemCollected(pendingPrizeId); if (isNew) { console.log("NEW ITEM!", prizeItem.name); collectedGachaItems[pendingPrizeId] = true; try { localStorage.setItem(`gacha_${pendingPrizeId}`, 'true'); console.log(`Saved gacha: ${pendingPrizeId}`); } catch (e) { console.warn(`LS save fail ${pendingPrizeId}:`, e); } if (prizeItem.rarity === 'super_rare') setGachaMikaCommentary(`NYA~! A ${prizeItem.name}!! SO RARE! ♡`); else if (prizeItem.rarity === 'rare') setGachaMikaCommentary(`Ooh! A ${prizeItem.name}! Pretty!`); else setGachaMikaCommentary(`Yay! New: ${prizeItem.name}!`); } else { console.log("DUPLICATE!", prizeItem.name); setGachaMikaCommentary(`Hmph. Another ${prizeItem.name}. Already got that...`); } prizeDisplay = { item: prizeItem, isNew: isNew }; } } pendingPrizeId = null; } else if (currentGachaStep === 'revealing' && gachaAnimationTimer > PULL_ANIMATION_DURATION + 90) { currentGachaStep = 'idle'; console.log(">>> Setting isGachaAnimating to FALSE"); isGachaAnimating = false; console.log("Gacha animation finished."); setGachaMikaCommentary("Ready for another go, Master? Hehe~"); prizeDisplay = null; } if (currentGachaStep === 'sparking' && frameCount % 4 === 0 && sparkParticles.length < MAX_SPARK_PARTICLES) { console.log(">>> Spawning Spark Particle..."); spawnSparkParticle(); } if ((currentGachaStep === 'shaking' || currentGachaStep === 'sparking' || currentGachaStep === 'poofing') && frameCount % 20 === 0 && smokeParticles.length < MAX_SMOKE_PARTICLES) { spawnSmokeParticle(machineBox.x + machineBox.w * 0.85, machineBox.y + machineBox.h * 0.1); } }

// --- Particle Spawning (ADDED LOGS) ---
function spawnSmokeParticle(x, y) { let p = { x: x+random(-5,5), y: y+random(-5,5), vx: random(-0.2,0.2), vy: random(-0.8,-0.3), size: random(15,30), alpha: random(100,180), life: 1.0 }; smokeParticles.push(p); }
function spawnSparkParticle() { let s=floor(random(4)); let x,y; if(!machineBox) return; if(s===0){x=machineBox.x+random(machineBox.w);y=machineBox.y;}else if(s===1){x=machineBox.x+random(machineBox.w);y=machineBox.y+machineBox.h;}else if(s===2){x=machineBox.x;y=machineBox.y+random(machineBox.h);}else{x=machineBox.x+machineBox.w;y=machineBox.y+random(machineBox.h);} let p = { x: x, y: y, vx: random(-2,2), vy: random(-2,2), len: random(5,15), life: 1.0, alpha: 255 }; sparkParticles.push(p); console.log(">>> Spawned Spark:", p); }
function spawnSpentPlushieParticles() { let px=machineBox.x+machineBox.w/2; let py=machineBox.y+machineBox.h*0.3; if(!plushieColors || !Array.isArray(plushieColors) || plushieColors.length === 0) {console.error("!!! Cannot spawn plushie particles: plushieColors invalid!"); return;} for(let i=0; i<MAX_PLUSHIE_PARTICLES; i++){ let p = { x:px+random(-10,10), y:py+random(-10,10), vx:random(-3,3), vy:random(-5,-1), size:random(8,15), color:random(plushieColors), angle:random(TWO_PI), spin:random(-0.1,0.1), life:1.0, alpha:255 }; spentPlushieParticles.push(p); console.log(">>> Spawned Spent Plushie:", p); } }

// --- Particle Updating ---
function updateSmokeParticles() { /* ... */ } function updateSparkParticles() { /* ... */ } function updateSpentPlushieParticles() { /* ... */ }

// --- Particle Drawing (ADDED LOGS) ---
function drawSmokeParticles() { noStroke(); for (let p of smokeParticles) { fill(150, p.alpha*p.life); ellipse(p.x,p.y,p.size); } }
function drawSparkParticles() { if (sparkParticles.length > 0) console.log(`>>> Drawing ${sparkParticles.length} Spark Particles. First:`, sparkParticles[0]); strokeWeight(2); for (let p of sparkParticles) { stroke(255,255,0,p.alpha); line(p.x,p.y, p.x+p.vx*p.len*p.life, p.y+p.vy*p.len*p.life); } noStroke(); }
function drawSpentPlushieParticles() { if (spentPlushieParticles.length > 0) console.log(`>>> Drawing ${spentPlushieParticles.length} Spent Plushie Particles. First:`, spentPlushieParticles[0]); rectMode(CENTER); for (let p of spentPlushieParticles) { push(); translate(p.x,p.y); rotate(p.angle); if(p.color) {fill(red(p.color), green(p.color), blue(p.color), p.alpha);} else {fill(128, p.alpha);} rect(0,0,p.size,p.size); pop(); } rectMode(CORNER); }

// --- Draw Prize Display ---
function drawPrizeDisplay() { /* ... */ }

// --- Handle Gacha Input (With Logs Inside Conditions) ---
function handleGachaInput(px, py, currentTotalPlushies) {
    console.log(`>>> handleGachaInput called. Click at: (${px.toFixed(1)}, ${py.toFixed(1)}). Animating=${isGachaAnimating}`);
    if (isGachaAnimating) { console.log(">>> Gacha animating, input blocked."); return true; }
    if (!gachaBackButton || typeof gachaBackButton.x === 'undefined') { console.error(">>> BACK BUTTON MISSING in handleGachaInput!"); return false; }
    if (!gachaPullButton || typeof gachaPullButton.x === 'undefined') { console.error(">>> PULL BUTTON MISSING in handleGachaInput!"); return false; }

    let isInsideBack = (px >= gachaBackButton.x && px <= gachaBackButton.x + gachaBackButton.w && py >= gachaBackButton.y && py <= gachaBackButton.y + gachaBackButton.h);
    // console.log(`>>> Checking Back Btn: Inside=${isInsideBack}`);
    if (isInsideBack) { console.log(">>> !!! Gacha Back button HIT !!!"); if(typeof gameState !== 'undefined') { gameState = 'start'; gachaMikaCommentary = ""; gachaMikaCommentaryTimer = 0; return 'back'; } else { console.error(">>> Cannot change gameState!"); return false; } }

    let isInsidePull = (px >= gachaPullButton.x && px <= gachaPullButton.x + gachaPullButton.w && py >= gachaPullButton.y && py <= gachaPullButton.y + gachaPullButton.h);
    // console.log(`>>> Checking Pull Btn: Inside=${isInsidePull}`);
    if (isInsidePull) {
        console.log(">>> !!! Gacha Pull button HIT !!!");
        let poolValid = (gachaColorPool.length > 0 && !gachaColorPool[0].startsWith('error_'));
        console.log(`>>> Pool Check: Valid=${poolValid}, Length=${gachaColorPool.length}`);
        if (poolValid) {
             if (typeof startGachaAnimation === 'function') {
                console.log(">>> Pool valid, calling startGachaAnimation...");
                startGachaAnimation(); // <-- Make sure spelling is right!
                return 'start_pull';
             } else { console.error(">>> startGachaAnimation function missing!"); return false; }
        } else {
            console.log(">>> Pool invalid, not starting animation.");
            if(typeof setGachaMikaCommentary === 'function') { setGachaMikaCommentary("Machine looks broken... Nya..."); }
            else { console.error(">>> setGachaMikaCommentary missing!"); }
            return 'pull_fail_pool';
        }
    }
    // console.log(">>> No Gacha button hit this time.");
    return false;
}

// --- Dependencies ---